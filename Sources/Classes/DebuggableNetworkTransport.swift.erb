//
//  DebuggableNetworkTransport.swift
//  ApolloDeveloperKit
//
//  Created by Ryosuke Ito on 6/15/19.
//  Copyright Â© 2019 Ryosuke Ito. All rights reserved.
//
<% require './Scripts/apollo_version' %>
<% apollo_version = ApolloVersion.guess %>

import Apollo

protocol DebuggableNetworkTransportDelegate: class {
    func networkTransport<Operation: GraphQLOperation>(_ networkTransport: DebuggableNetworkTransport, willSendOperation operation: Operation)
    func networkTransport<Operation: GraphQLOperation>(_ networkTransport: DebuggableNetworkTransport, didSendOperation operation: Operation, response: GraphQLResponse<Operation>?, error: Error?)
}

/**
 * `DebuggableNetworkTransport` is a bridge between `ApolloDebugServer` and `ApolloClient`.
 *
 * You should instantiate both `ApolloDebugServer` and `ApolloClient` with the same instance of this class.
 */
public class DebuggableNetworkTransport {
    weak var delegate: DebuggableNetworkTransportDelegate?
    private let networkTransport: NetworkTransport

    /**
     * Initializes the receiver with the underlying network transport object.
     *
     * - Parameter networkTransport: The underlying network transport.
     */
    public init(networkTransport: NetworkTransport) {
        self.networkTransport = networkTransport
    }
}

// MARK: NetworkTransport

extension DebuggableNetworkTransport: NetworkTransport {
<% if apollo_version < '0.13.0' %>
    public func send<Operation>(operation: Operation, completionHandler: @escaping (GraphQLResponse<Operation>?, Error?) -> Void) -> Cancellable where Operation: GraphQLOperation {
        delegate?.networkTransport(self, willSendOperation: operation)
        return networkTransport.send(operation: operation) { [weak self] response, error in
            if let self = self {
                self.delegate?.networkTransport(self, didSendOperation: operation, response: response, error: error)
            }
            completionHandler(response, error)
        }
    }
<% else %>

    public func send<Operation>(operation: Operation, completionHandler: @escaping (Result<GraphQLResponse<Operation>, Error>) -> Void) -> Cancellable where Operation : GraphQLOperation {
        delegate?.networkTransport(self, willSendOperation: operation)
        return networkTransport.send(operation: operation) { [weak self] result in
            if let self = self {
                switch result {
                case .success(let response):
                    self.delegate?.networkTransport(self, didSendOperation: operation, response: response, error: nil)
                case .failure(let error):
                    self.delegate?.networkTransport(self, didSendOperation: operation, response: nil, error: error)
                }
            }
            completionHandler(result)
        }
    }
<% end %>
}
